import {SQSClient} from '@aws-sdk/client-sqs';
import {SendMessageCommand} from '@aws-sdk/client-sqs';
import {DynamoDBClient, GetItemCommand} from '@aws-sdk/client-dynamodb';

export const sqsClient = new SQSClient();
export const dynamoClient = new DynamoDBClient();

export class Context {
  args;

  frameId;
  frame;

  parentFrameId;
  returnFnName;

  constructor(args, frameId, frame, parentFrameId, returnFnName) {
    this.args = args;
    this.frameId = frameId;
    this.frame = frame;
    this.parentFrameId = parentFrameId;
    this.returnFnName = returnFnName;
  }

  static async fromMessage(message) {
    const frameId = message.messageAttributes?.frameId?.stringValue;
    const frame = frameId ? await Context.getFrame(frameId) : {};

    return new Context(
      JSON.parse(message.body),
      frameId,
      frame,
      message.messageAttributes?.parentFrameId?.stringValue,
      message.messageAttributes?.returnFnName?.stringValue
    );
  }

  async call(fnName, args, returnFnName) {
    // push the current frame onto the stack
    if (this.frameId) {
      await dynamoClient.send(new PutItemCommand({
        TableName: 'frame-table',
        Item: {
          frameId: { S: this.frameId },
          frame: { S: JSON.stringify(this.frame) },
          ...(this.parentFrameId ? { parentFrameId: { S: this.parentFrameId } } : {}),
        }
      }));
    }

    const requestQueueUrl = `${process.env.SQS_BASE_URL}/${fnName}-request-queue`;

    sqsClient.send(new SendMessageCommand({
      QueueUrl: requestQueueUrl,
      MessageAttributes: {
        parentFrameId: {
          DataType: 'String',
          StringValue: this.frameId,
        },
        returnFnName: {
          DataType: 'String',
          StringValue: returnFnName
        }
      },
      MessageBody: JSON.stringify(args)
    }));
  }

  // TODO - delete the current frame from the stack
  async return(result) {
    const parentFrame = await Context.getFrame(this.parentFrameId);

    const requestQueueUrl = `${process.env.SQS_BASE_URL}/${this.returnFnName}-request-queue`;

    sqsClient.send(new SendMessageCommand({
      QueueUrl: requestQueueUrl,
      MessageAttributes: {
        parentFrameId: {
          DataType: 'String',
          StringValue: this.frameId,
        },
        returnFnName: {
          DataType: 'String',
          StringValue: returnFnName
        }
      },
      MessageBody: JSON.stringify(args)
    }));
  }

  static async resolveFrame(frameId) {
    if (!frameId) {
      return {};
    }

    const getItemResponse = await dynamoClient.send(new GetItemCommand({
      TableName: 'frame-table',
      Key: {
        frameId: { S: frameId }
      }
    }));

    return getItemResponse.Item;
  }

  static async getFrame(frameId) {
    const getItemResponse = await dynamoClient.send(new GetItemCommand({
      TableName: 'frame-table',
      Key: {
        frameId: { S: frameId }
      }
    }));

    if (!getItemResponse.Item) {
      throw new Error("Frame not found: " + frameId);
    }

    return getItemResponse.Item;
  }
}


export const eventHandler = (fn) => async (event) => {
  try {
    if (event.Records) {
      console.info(`Processing ${event.Records.length} messages.`);

      for (const message of event.Records) {
        fn(await Context.fromMessage(message));
      }
    } else {
      console.info('Processing request event');

      const args = parseHttpArgs(event.body);

      return {
        statusCode: 200,
        body: JSON.stringify(await fn.apply(null, args), null, 2)
      }
    }
  } catch (e) {
    console.log(e)
    return e
  }
}

export async function handleRequestMessage(message, fn) {
  fn(await Context.fromMessage(message));
}

export function parseHttpArgs(argsString) {
  let args = (typeof argsString === 'undefined' || argsString.trim().length === 0) 
    ? [] 
    : JSON.parse(argsString) 

  if (!Array.isArray(args)) {
    args = [args]
  }
}

async function request(requestQueueUrl, argsString) {
  const requestId = crypto.randomUUID();

  console.log(`Sending request with ID ${requestId}`);

  await sqsClient.send(new SendMessageCommand({
    QueueUrl: requestQueueUrl,
    MessageAttributes: {
      OriginRequestId: {
        DataType: 'String',
        StringValue: requestId
      }
    },
    MessageBody: argsString
  }));

  for (let attempt = 0; attempt < 30; attempt++) {
    console.log(`Waiting for response, attempt ${attempt + 1}...`);

    try {
      const response = await dynamoClient.send(new GetItemCommand({
        TableName: 'response-table',
        Key: {
          'request-id': { S: requestId }
        }
      }));

      if (response.Item) {
        console.log("Found response in DynamoDB:", response.Item);
        const result = response.Item.result.S;
        return JSON.parse(result);
      }
    } catch (error) {
      console.log("Error checking DynamoDB:", error);
    }

    // Wait before next attempt
    await new Promise(resolve => setTimeout(resolve, 2000));
  }

  throw new Error("Did not receive a response for requestId: " + requestId);
}
