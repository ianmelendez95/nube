import {SQSClient} from '@aws-sdk/client-sqs';
import {SendMessageCommand} from '@aws-sdk/client-sqs';
import {DynamoDBClient, GetItemCommand, UpdateItemCommand, PutItemCommand} from '@aws-sdk/client-dynamodb';
import { DeleteItemCommand } from '@aws-sdk/client-dynamodb';

export const sqsClient = new SQSClient();
export const dynamoClient = new DynamoDBClient();

class Logger { 
  log(...args) {
    console.log(...args);
  }

  trace(...args) {
    console.log(...args);
  }
}

const log = new Logger();

export class Context {
  args;

  frameId;
  frame;

  contFrameId;
  contFnName;

  constructor(args, frameId, frame, contFrameId, contFnName) {
    this.args = args;
    this.frameId = frameId;
    this.frame = frame;
    this.contFrameId = contFrameId;
    this.contFnName = contFnName;
  }

  static async fromHttpReq(body) {
    log.trace('Context.fromHttpReq', body);
    const args = parseHttpArgs(body);
    const frameItem = await Context.makeNewFrameItem(undefined, undefined);

    return Context.fromArgsAndFrameItem(args, frameItem);
  }

  static async fromMessage(message) {
    log.trace('Context.fromMessage', message);
    const frameId = message.messageAttributes.frameId.stringValue;
    const frameItem = await Context.getFrameItem(frameId);

    const args = JSON.parse(message.body);

    return Context.fromArgsAndFrameItem(args, frameItem);
  }

  static fromArgsAndFrameItem(args, frameItem) {
    log.trace('Context.fromArgsAndFrameItem', args, frameItem);
    return new Context(
      args,
      frameItem.frameId.S,
      JSON.parse(frameItem.frame.S),
      frameItem.contFrameId?.S,
      frameItem.contFnName?.S
    )
  }

  /**
   * Call with current continuation.
   * Essentially, call the function and when it 'returns', call with the current frame.
   */
  async callCC(fnName, args, contFnName) {
    log.trace('Context.callCC', fnName, args, contFnName);
    await this.saveFrame(); // commit current frame updates

    // 'push' the current frame onto the 'stack' (even in this stretched analogy it's more of a 'heap' but whatever)
    const nextFrameItem = await Context.makeNewFrameItem(
      this.frameId,
      contFnName,
    ); 

    // invoke the function by sending a message to its SQS queue
    return Context.invoke(fnName, args, nextFrameItem.frameId.S);
  }

  /**
   * 'Return', which is really just calling the current continuation with the result.
   */
  async return(result) {
    log.trace('Context.return', result);
    // TODO - delete the current frame
    return Context.invoke(this.contFnName, [result], this.contFrameId);
  }

  async saveFrame() {
    return Context.updateFrame(this.frameId, this.frame);
  }

  static async invoke(fnName, args, frameId) {
    log.trace('Context.invoke', fnName, args, frameId);
    sqsClient.send(new SendMessageCommand({
      QueueUrl: `${process.env.SQS_BASE_URL}/${fnName}-request-queue`,
      MessageAttributes: {
        frameId: {
          DataType: 'String',
          StringValue: frameId,
        },
      },
      MessageBody: JSON.stringify([args])
    }));
  }

  static async deleteFrame(frameId) {
    log.trace('Context.deleteFrame', frameId);
    return dynamoClient.send(new DeleteItemCommand({
      TableName: 'frame-table',
      Key: {
        frameId: { S: frameId }
      }
    }));
  }

  static async updateFrame(frameId, frame) {
    log.trace('Context.updateFrame', frameId, frame);
    return dynamoClient.send(new UpdateItemCommand({
      TableName: 'frame-table',
      Key: {
        frameId: { S: frameId }
      },
      UpdateExpression: 'SET frame = :frame',
      ExpressionAttributeValues: {
        ':frame': { S: JSON.stringify(frame) }
      }
    }));
  }

  static async makeNewFrameItem(contFrameId, contFnName) {
    log.trace('Context.makeNewFrameItem', contFrameId, contFnName);
    const newFrame = {
      frameId: { S: crypto.randomUUID() },
      frame: { S: "{}" },
    }

    if (contFrameId) {
      newFrame.contFrameId = { S: contFrameId };
    }

    if (contFnName) {
      newFrame.contFnName = { S: contFnName };
    }

    await dynamoClient.send(new PutItemCommand({
      TableName: 'frame-table',
      Item: newFrame
    }));

    return newFrame;
  }

  static async getFrameItem(frameId) {
    log.trace('Context.getFrameItem', frameId);
    const getItemResponse = await dynamoClient.send(new GetItemCommand({
      TableName: 'frame-table',
      Key: {
        frameId: { S: frameId }
      }
    }));

    if (!getItemResponse.Item) {
      throw new Error("Frame not found: " + frameId);
    }

    return getItemResponse.Item;
  }
}

export const eventHandler = (fn) => async (event) => {
  try {
    if (event.Records) {
      console.info(`Processing ${event.Records.length} messages.`);

      for (const message of event.Records) {
        fn(await Context.fromMessage(message));
      }
    } else {
      console.info('Processing request event');

      const ctx = await Context.fromHttpReq(event.body);
      fn(ctx);

      return {
        statusCode: 200,
        body: 'Started execution'
      }
    }
  } catch (e) {
    console.log(e)
    return e
  }
}

export function parseHttpArgs(argsString) {
  log.trace('parseHttpArgs', argsString);
  let args = (typeof argsString === 'undefined' || argsString.trim().length === 0) 
    ? [] 
    : JSON.parse(argsString) 

  if (!Array.isArray(args)) {
    args = [args]
  }

  return args;
}
