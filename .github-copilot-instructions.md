# GitHub Copilot Instructions for Nube

## Project Overview

**Nube** is a Haskell-based JavaScript compiler that transforms async JavaScript functions into cloud-native AWS Lambda microservices. It's a parody project that takes microservices to the extreme - every function becomes a separate API endpoint.

### Core Concept
- **Input**: JavaScript file with async functions only
- **Output**: Complete AWS CloudFormation stack where each function is a separate Lambda API endpoint
- **Compilation Process**: Parses JS → Generates Lambda handlers → Creates proxy functions → Builds CloudFormation template → Generates deployment scripts

## Architecture

### Main Modules

1. **`src/Nube.hs`** - Main compilation orchestrator
   - Entry point for `compileFile` function
   - Validates JS file names (must be `.js` with letters-only basename)
   - Coordinates parsing, generation, and output writing

2. **`src/JS/Parse.hs`** - JavaScript parser using Megaparsec
   - Parses async function definitions only
   - Extracts function name, parameters, and body text
   - Creates `Script` and `Fun` data structures

3. **`src/JS/Syntax.hs`** - JavaScript AST data types
   - `Script`: Contains script name and list of functions
   - `Fun`: Contains function name, parameters text, and body text

4. **`src/Gen/Lambda.hs`** - Lambda function generation
   - Generates Lambda handler scripts for each function
   - Creates proxy functions that make HTTP calls to other Lambda endpoints
   - Uses Julius templates for code generation
   - Creates deployment bash scripts

5. **`src/Gen/CF.hs`** - CloudFormation template generation
   - Generates complete CF template with all AWS resources
   - Creates API Gateway, Lambda functions, IAM roles, S3 bucket refs
   - Uses Aeson for JSON generation

6. **`src/Util/Aeson.hs`** - JSON utilities for pretty-printing

### Template System

Uses Julius templates in `template/` directory:
- **`js/handler.julius`** - Lambda handler wrapper template
- **`js/proxy.julius`** - Proxy function template for inter-function HTTP calls
- **`js/proxy-request.julius`** - HTTP request logic with retry mechanism
- **`bash/deploy.julius`** - Deployment script template

## Key Constraints & Design Decisions

### JavaScript Limitations
- **ASYNC FUNCTIONS ONLY** - The compiler only accepts async functions
- **No synchronous functions** - Converting sync to async with proper control flow is complex
- **Simple parsing** - Uses text-based parsing, not full AST analysis
- **Function calls become HTTP requests** - Each function call is converted to an API call

### Haskell Patterns
- **Megaparsec for parsing** - Custom JS parser that extracts function definitions
- **Julius for templating** - Template Haskell for generating JavaScript and bash code
- **Aeson for JSON** - CloudFormation template generation with proper JSON encoding
- **Stack build system** - Uses stack.yaml for dependency management

### AWS Architecture Generated
- **One Lambda per function** - Each JS function becomes a separate Lambda
- **API Gateway integration** - HTTP API Gateway routes requests to Lambda functions
- **Shared Lambda Layer** - Contains proxy functions for inter-function communication
- **S3 bucket deployment** - Code and templates uploaded to S3 for CloudFormation
- **IAM roles and permissions** - Proper security setup for Lambda execution

## Development Guidelines

### When working on the parser (`JS/Parse.hs`):
- Remember it only handles async functions
- Function body parsing uses custom logic to handle nested braces
- Parameters are captured as raw text, not parsed into AST
- Parser is whitespace-aware but preserves original formatting

### When working on code generation (`Gen/Lambda.hs`):
- Handler generation wraps original function with Lambda event handling
- Proxy generation creates HTTP client code that calls other Lambda endpoints
- Each function script includes imports for proxy dependencies
- Use Julius templates for all code generation

### When working on CloudFormation (`Gen/CF.hs`):
- Every resource needs proper naming with capitalized prefixes
- Lambda functions require S3 code references, IAM roles, and environment variables
- API Gateway needs integrations, routes, and permissions for each Lambda
- Resource references use CloudFormation Ref and GetAtt functions

### When adding new features:
- Consider the async-only constraint - synchronous functions would require major changes
- Template changes require updates to both Julius files and generation logic
- CloudFormation changes need corresponding updates in deployment scripts
- All generated code must handle the HTTP proxy pattern

### Testing approach:
- Use example JS files in `example/` directory
- Test compilation with `stack exec nube -- example.js`
- Verify generated dist/ directory structure
- Check CloudFormation template validity
- Validate deployment script functionality

### Error handling principles:
- Validate JS file extensions and naming early
- Parser should give clear error messages for invalid JS syntax
- CloudFormation generation should create valid templates
- Deployment scripts should check AWS CLI availability and permissions

## Common Operations

### Adding a new CloudFormation resource type:
1. Add data type to `Gen/CF.hs`
2. Implement `ToJSON` instance
3. Update template generation in `templateFromScript`
4. Add to resource list in Template JSON generation

### Adding new Julius template features:
1. Create/modify template file in `template/`
2. Update generation function in `Gen/Lambda.hs`
3. Ensure variable interpolation uses `#{rawJS variable_name}` syntax
4. Test with example compilation

### Debugging compilation issues:
1. Check JS parsing with simple async function
2. Verify Julius template rendering
3. Validate CloudFormation JSON structure
4. Test deployment script generation

This is a fun, experimental project that demonstrates cloud architecture concepts through extreme microservices. The codebase prioritizes clarity and demonstration over production readiness.